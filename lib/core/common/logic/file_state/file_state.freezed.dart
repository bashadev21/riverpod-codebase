// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'file_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$FileState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FileStateCopyWith<$Res> {
  factory $FileStateCopyWith(FileState value, $Res Function(FileState) then) =
      _$FileStateCopyWithImpl<$Res, FileState>;
}

/// @nodoc
class _$FileStateCopyWithImpl<$Res, $Val extends FileState>
    implements $FileStateCopyWith<$Res> {
  _$FileStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FileStateInitialImplCopyWith<$Res> {
  factory _$$FileStateInitialImplCopyWith(_$FileStateInitialImpl value,
          $Res Function(_$FileStateInitialImpl) then) =
      __$$FileStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FileStateInitialImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateInitialImpl>
    implements _$$FileStateInitialImplCopyWith<$Res> {
  __$$FileStateInitialImplCopyWithImpl(_$FileStateInitialImpl _value,
      $Res Function(_$FileStateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FileStateInitialImpl implements _FileStateInitial {
  const _$FileStateInitialImpl();

  @override
  String toString() {
    return 'FileState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FileStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _FileStateInitial implements FileState {
  const factory _FileStateInitial() = _$FileStateInitialImpl;
}

/// @nodoc
abstract class _$$FileStateLoadingImplCopyWith<$Res> {
  factory _$$FileStateLoadingImplCopyWith(_$FileStateLoadingImpl value,
          $Res Function(_$FileStateLoadingImpl) then) =
      __$$FileStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FileStateLoadingImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateLoadingImpl>
    implements _$$FileStateLoadingImplCopyWith<$Res> {
  __$$FileStateLoadingImplCopyWithImpl(_$FileStateLoadingImpl _value,
      $Res Function(_$FileStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FileStateLoadingImpl implements _FileStateLoading {
  const _$FileStateLoadingImpl();

  @override
  String toString() {
    return 'FileState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FileStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _FileStateLoading implements FileState {
  const factory _FileStateLoading() = _$FileStateLoadingImpl;
}

/// @nodoc
abstract class _$$FileStateDataImplCopyWith<$Res> {
  factory _$$FileStateDataImplCopyWith(
          _$FileStateDataImpl value, $Res Function(_$FileStateDataImpl) then) =
      __$$FileStateDataImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FileStateDataImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateDataImpl>
    implements _$$FileStateDataImplCopyWith<$Res> {
  __$$FileStateDataImplCopyWithImpl(
      _$FileStateDataImpl _value, $Res Function(_$FileStateDataImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FileStateDataImpl implements _FileStateData {
  const _$FileStateDataImpl();

  @override
  String toString() {
    return 'FileState.data()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FileStateDataImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return data();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return data?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class _FileStateData implements FileState {
  const factory _FileStateData() = _$FileStateDataImpl;
}

/// @nodoc
abstract class _$$FileStateMultiFileImplCopyWith<$Res> {
  factory _$$FileStateMultiFileImplCopyWith(_$FileStateMultiFileImpl value,
          $Res Function(_$FileStateMultiFileImpl) then) =
      __$$FileStateMultiFileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FilePickerResult? data});
}

/// @nodoc
class __$$FileStateMultiFileImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateMultiFileImpl>
    implements _$$FileStateMultiFileImplCopyWith<$Res> {
  __$$FileStateMultiFileImplCopyWithImpl(_$FileStateMultiFileImpl _value,
      $Res Function(_$FileStateMultiFileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$FileStateMultiFileImpl(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as FilePickerResult?,
    ));
  }
}

/// @nodoc

class _$FileStateMultiFileImpl implements _FileStateMultiFile {
  const _$FileStateMultiFileImpl({this.data});

  @override
  final FilePickerResult? data;

  @override
  String toString() {
    return 'FileState.multiImage(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FileStateMultiFileImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FileStateMultiFileImplCopyWith<_$FileStateMultiFileImpl> get copyWith =>
      __$$FileStateMultiFileImplCopyWithImpl<_$FileStateMultiFileImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return multiImage(this.data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return multiImage?.call(this.data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (multiImage != null) {
      return multiImage(this.data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return multiImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return multiImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (multiImage != null) {
      return multiImage(this);
    }
    return orElse();
  }
}

abstract class _FileStateMultiFile implements FileState {
  const factory _FileStateMultiFile({final FilePickerResult? data}) =
      _$FileStateMultiFileImpl;

  FilePickerResult? get data;
  @JsonKey(ignore: true)
  _$$FileStateMultiFileImplCopyWith<_$FileStateMultiFileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FileStateSingleFileImplCopyWith<$Res> {
  factory _$$FileStateSingleFileImplCopyWith(_$FileStateSingleFileImpl value,
          $Res Function(_$FileStateSingleFileImpl) then) =
      __$$FileStateSingleFileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FilePickerResult? data});
}

/// @nodoc
class __$$FileStateSingleFileImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateSingleFileImpl>
    implements _$$FileStateSingleFileImplCopyWith<$Res> {
  __$$FileStateSingleFileImplCopyWithImpl(_$FileStateSingleFileImpl _value,
      $Res Function(_$FileStateSingleFileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$FileStateSingleFileImpl(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as FilePickerResult?,
    ));
  }
}

/// @nodoc

class _$FileStateSingleFileImpl implements _FileStateSingleFile {
  const _$FileStateSingleFileImpl({this.data});

  @override
  final FilePickerResult? data;

  @override
  String toString() {
    return 'FileState.singleImage(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FileStateSingleFileImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FileStateSingleFileImplCopyWith<_$FileStateSingleFileImpl> get copyWith =>
      __$$FileStateSingleFileImplCopyWithImpl<_$FileStateSingleFileImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return singleImage(this.data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return singleImage?.call(this.data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (singleImage != null) {
      return singleImage(this.data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return singleImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return singleImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (singleImage != null) {
      return singleImage(this);
    }
    return orElse();
  }
}

abstract class _FileStateSingleFile implements FileState {
  const factory _FileStateSingleFile({final FilePickerResult? data}) =
      _$FileStateSingleFileImpl;

  FilePickerResult? get data;
  @JsonKey(ignore: true)
  _$$FileStateSingleFileImplCopyWith<_$FileStateSingleFileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FileStateAudioImplCopyWith<$Res> {
  factory _$$FileStateAudioImplCopyWith(_$FileStateAudioImpl value,
          $Res Function(_$FileStateAudioImpl) then) =
      __$$FileStateAudioImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FilePickerResult? data});
}

/// @nodoc
class __$$FileStateAudioImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateAudioImpl>
    implements _$$FileStateAudioImplCopyWith<$Res> {
  __$$FileStateAudioImplCopyWithImpl(
      _$FileStateAudioImpl _value, $Res Function(_$FileStateAudioImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$FileStateAudioImpl(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as FilePickerResult?,
    ));
  }
}

/// @nodoc

class _$FileStateAudioImpl implements _FileStateAudio {
  const _$FileStateAudioImpl({this.data});

  @override
  final FilePickerResult? data;

  @override
  String toString() {
    return 'FileState.audio(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FileStateAudioImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FileStateAudioImplCopyWith<_$FileStateAudioImpl> get copyWith =>
      __$$FileStateAudioImplCopyWithImpl<_$FileStateAudioImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return audio(this.data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return audio?.call(this.data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (audio != null) {
      return audio(this.data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return audio(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return audio?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (audio != null) {
      return audio(this);
    }
    return orElse();
  }
}

abstract class _FileStateAudio implements FileState {
  const factory _FileStateAudio({final FilePickerResult? data}) =
      _$FileStateAudioImpl;

  FilePickerResult? get data;
  @JsonKey(ignore: true)
  _$$FileStateAudioImplCopyWith<_$FileStateAudioImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FileStateFileImplCopyWith<$Res> {
  factory _$$FileStateFileImplCopyWith(
          _$FileStateFileImpl value, $Res Function(_$FileStateFileImpl) then) =
      __$$FileStateFileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FilePickerResult? data});
}

/// @nodoc
class __$$FileStateFileImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateFileImpl>
    implements _$$FileStateFileImplCopyWith<$Res> {
  __$$FileStateFileImplCopyWithImpl(
      _$FileStateFileImpl _value, $Res Function(_$FileStateFileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$FileStateFileImpl(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as FilePickerResult?,
    ));
  }
}

/// @nodoc

class _$FileStateFileImpl implements _FileStateFile {
  const _$FileStateFileImpl({this.data});

  @override
  final FilePickerResult? data;

  @override
  String toString() {
    return 'FileState.file(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FileStateFileImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FileStateFileImplCopyWith<_$FileStateFileImpl> get copyWith =>
      __$$FileStateFileImplCopyWithImpl<_$FileStateFileImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return file(this.data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return file?.call(this.data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (file != null) {
      return file(this.data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return file(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return file?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (file != null) {
      return file(this);
    }
    return orElse();
  }
}

abstract class _FileStateFile implements FileState {
  const factory _FileStateFile({final FilePickerResult? data}) =
      _$FileStateFileImpl;

  FilePickerResult? get data;
  @JsonKey(ignore: true)
  _$$FileStateFileImplCopyWith<_$FileStateFileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FileStateErrorImplCopyWith<$Res> {
  factory _$$FileStateErrorImplCopyWith(_$FileStateErrorImpl value,
          $Res Function(_$FileStateErrorImpl) then) =
      __$$FileStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? e});
}

/// @nodoc
class __$$FileStateErrorImplCopyWithImpl<$Res>
    extends _$FileStateCopyWithImpl<$Res, _$FileStateErrorImpl>
    implements _$$FileStateErrorImplCopyWith<$Res> {
  __$$FileStateErrorImplCopyWithImpl(
      _$FileStateErrorImpl _value, $Res Function(_$FileStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? e = freezed,
  }) {
    return _then(_$FileStateErrorImpl(
      e: freezed == e
          ? _value.e
          : e // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$FileStateErrorImpl implements _FileStateError {
  const _$FileStateErrorImpl({this.e});

  @override
  final String? e;

  @override
  String toString() {
    return 'FileState.error(e: $e)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FileStateErrorImpl &&
            (identical(other.e, e) || other.e == e));
  }

  @override
  int get hashCode => Object.hash(runtimeType, e);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FileStateErrorImplCopyWith<_$FileStateErrorImpl> get copyWith =>
      __$$FileStateErrorImplCopyWithImpl<_$FileStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(FilePickerResult? data) multiImage,
    required TResult Function(FilePickerResult? data) singleImage,
    required TResult Function(FilePickerResult? data) audio,
    required TResult Function(FilePickerResult? data) file,
    required TResult Function(String? e) error,
  }) {
    return error(e);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? data,
    TResult? Function(FilePickerResult? data)? multiImage,
    TResult? Function(FilePickerResult? data)? singleImage,
    TResult? Function(FilePickerResult? data)? audio,
    TResult? Function(FilePickerResult? data)? file,
    TResult? Function(String? e)? error,
  }) {
    return error?.call(e);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(FilePickerResult? data)? multiImage,
    TResult Function(FilePickerResult? data)? singleImage,
    TResult Function(FilePickerResult? data)? audio,
    TResult Function(FilePickerResult? data)? file,
    TResult Function(String? e)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(e);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FileStateInitial value) initial,
    required TResult Function(_FileStateLoading value) loading,
    required TResult Function(_FileStateData value) data,
    required TResult Function(_FileStateMultiFile value) multiImage,
    required TResult Function(_FileStateSingleFile value) singleImage,
    required TResult Function(_FileStateAudio value) audio,
    required TResult Function(_FileStateFile value) file,
    required TResult Function(_FileStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FileStateInitial value)? initial,
    TResult? Function(_FileStateLoading value)? loading,
    TResult? Function(_FileStateData value)? data,
    TResult? Function(_FileStateMultiFile value)? multiImage,
    TResult? Function(_FileStateSingleFile value)? singleImage,
    TResult? Function(_FileStateAudio value)? audio,
    TResult? Function(_FileStateFile value)? file,
    TResult? Function(_FileStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FileStateInitial value)? initial,
    TResult Function(_FileStateLoading value)? loading,
    TResult Function(_FileStateData value)? data,
    TResult Function(_FileStateMultiFile value)? multiImage,
    TResult Function(_FileStateSingleFile value)? singleImage,
    TResult Function(_FileStateAudio value)? audio,
    TResult Function(_FileStateFile value)? file,
    TResult Function(_FileStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _FileStateError implements FileState {
  const factory _FileStateError({final String? e}) = _$FileStateErrorImpl;

  String? get e;
  @JsonKey(ignore: true)
  _$$FileStateErrorImplCopyWith<_$FileStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
